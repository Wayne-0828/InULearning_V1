好的，各位夥伴，大家好。

我是 InULearning 專案的資深全端工程師。今天非常榮幸能和大家分享我們這個專案從理念到實踐的完整技術藍圖。我會從專案的初衷開始，一路深入到前端、後端，以及資料庫的設計細節，分享我們團隊在過程中的思考、挑戰與決策。

---

## 1. 專案動機

#### 為什麼我們要做 InULearning？

在開始談技術之前，我想先回到原點：**我們想解決什麼問題？**

根據我們的觀察 (`00_project_summary.md`)，傳統的學習模式存在著幾個核心痛點：
* **對學生而言**：學習像是個黑盒子。他們不斷地練習，卻不清楚自己的弱點到底在哪，遇到挫折時也缺乏即時、有效的支援，很容易就失去學習的熱情。
* **對家長而言**：他們充滿焦慮。因為資訊不對稱，只能看到孩子的成績單，卻無法真正理解學習過程中的困難，過度的關心有時反而造成親子關係的緊張。
* **對老師而言**：他們分身乏術。一個班級這麼多學生，很難針對每個人的痛點對症下藥，真正做到因材施教。

因此，我們的動機很明確：**打造一個高效、精準、溫暖的個人化學習生態系**。我們希望透過 AI 技術，精準診斷學習弱點，提供個人化的學習方案，並成為串連學生、家長和老師之間的溝通橋樑。

---

## 2. 專案目標

#### 我們希望達到什麼樣的成果？

為了實現上述的願景，我們設定了幾個清晰、可量化的目標 (`00_project_summary.md`, `02_system_architecture_document.md`)：

* **主要目標**：
    1.  **精準診斷**：建立一個由 AI 驅動的學習診斷系統，能自動分析學生的練習數據，生成視覺化的弱點報告。
    2.  **個人化治療**：不僅僅是找出問題，更要提供客製化的複習內容與相似題練習，有效提升學習效率。
    3.  **優化溝通**：建立家長與教師儀表板，將數據轉化為有溫度的溝通建議，讓家長從「監督者」轉變為「支持者」。

* **成功的樣貌 (KPIs)**：
    * **可用性**：系統達到 `99.9%` 的可用性。
    * **高效能**：API 回應時間 P95 控制在 `500ms` 以內。
    * **高準確性**：學習弱點診斷準確度超過 `85%`。

這些目標是我們所有技術決策的北極星，指引我們在效能、成本和開發速度之間做出權衡。

---

## 3. 前端設計

#### 我們如何打造使用者體驗？

在前端，我們的核心原則是**前後端分離** (`04_api_design.md`)，讓前端專注於打造流暢的使用者體驗，而後端專注於穩定的業務邏輯。

* **技術選型原因** (`02_system_architecture_document.md`)：
    * 我們在 MVP 階段選擇了**原生 HTML, CSS, JavaScript 搭配 Bootstrap 5**。
    * **為什麼這麼選？** 我們的目標是快速驗證核心學習流程。這個技術棧輕量、學習曲線平緩，能讓我們迅速迭代，避免了在初期就引入如 React 或 Vue 這類重型框架所帶來的工程複雜度。Bootstrap 5 則確保了我們的介面在不同裝置上都有一致的響應式體驗。

* **程式設計邏輯** (`07_project_structure.md`, `08_file_dependencies.md`)：
    * 我們將前端應用按角色拆分為 `student-app`, `parent-app` 等獨立模組。
    * 在每個應用內部，我們採用了**元件化**的思想。例如，在學生端，`exercise.js` 負責題目渲染與互動，`results.js` 負責結果展示。
    * 所有與後端的通訊都透過一個統一的 `ApiClient` 模組，它負責呼叫後端的 API Gateway (Nginx)。這種設計讓 API 的管理變得非常集中和清晰。

* **實作遇到的困難與解決方案**：
    * **困難**：如何管理跨頁面的使用者狀態（例如登入資訊、練習進度）而又不引入複雜的狀態管理庫？
    * **解決方案**：我們設計了一個輕量級的 `StateManager`，利用瀏覽器的 `sessionStorage` 和 `localStorage` 來持久化 JWT Token 和非敏感的會話數據。同時，透過自定義事件 (Custom Events) 在不同元件之間傳遞消息，實現了低耦合的狀態同步，完美滿足了 MVP 階段的需求。

---

## 4. 後端設計

#### 系統的大腦與骨幹是如何運作的？

後端是我們整個平台的核心，我們採用了**微服務架構**，確保系統的**高內聚、低耦合**，從而提升可擴展性與可維護性。

* **技術選型原因** (`02_system_architecture_document.md`)：
    * **Python + FastAPI**：Python 是 AI/ML 領域的首選語言，擁有豐富的生態。FastAPI 則是一個基於 Starlette 的高效能非同步框架，它內建的 Pydantic 資料驗證和自動生成 OpenAPI 文檔的功能，極大地提升了我們的開發效率與 API 品質。
    * **Docker & Docker Compose**：容器化是微服務的標配。它讓我們能夠標準化開發、測試和生產環境，實現一鍵啟動整個服務叢集，徹底解決了「在我電腦上可以跑」的問題。
    * **Nginx API Gateway**：作為所有前端請求的統一入口，Nginx 負責路由分發、負載均衡、速率限制和 SSL 卸載，是我們系統的第一道防線。

* **程式設計邏輯** (`03_system_design_document.md`)：
    * 我們以**領域驅動設計 (DDD)** 的思想劃分了多個微服務，例如：`auth-service`、`learning-service`、`question-bank-service` 和 `ai-analysis-service`。
    * 以核心的 `learning-service` 為例，我們內部採用了**分層架構**：
        1.  `Controller/Router` 層：負責處理 HTTP 請求，驗證參數。
        2.  `Service` 層：封裝核心業務邏輯，協調各個子元件，例如 `ExerciseGenerator` (出題) 和 `GradingCoordinator` (批改)。
        3.  `Repository` 層：透過介面 (`ILearningRepository`) 抽象化資料庫操作，實現業務邏輯與數據存取的解耦。
    * 這種設計遵循 **SOLID 原則**，特別是**依賴反轉原則**，讓我們的程式碼變得高度可測試和可替換。

* **API 設計邏輯** (`04_api_design.md`)：
    * 我們遵循 **RESTful** 風格，以資源為中心，使用名詞複數來命名 URL (e.g., `/learning/sessions`)。
    * 所有 API 都透過 `/api/v1` 進行版本控制，確保未來的升級不會破壞現有客戶端。
    * 我們設計了**統一的回應格式**，無論成功或失敗，前端都能用一致的方式處理。
    * 一個很好的例子是 `POST /learning/sessions/{session_id}/submit` 這個端點。它不僅僅回傳分數，更重要的是，它會回傳一個包含 `explanation`（詳解）和 `weakness_analysis`（弱點分析）的豐富 JSON 物件。**這個 API 的設計直接體現了我們專案的核心價值：提供深度分析而不僅僅是淺層結果。**

* **實作遇到的困難與解決方案** (`01_adr_template.md`)：
    * **困難**：AI 分析（如弱點分析、生成詳解）可能是個耗時操作，如果同步執行，會導致 API 超時，嚴重影響使用者體驗。
    * **解決方案**：我們需要一個非同步任務佇列。最初考慮了功能強大的 RabbitMQ + Celery，但這會為 MVP 階段帶來額外的基礎設施複雜度和學習成本。經過評估，我們做出了一個關鍵決策（ADR-001）：**在 MVP 階段採用 Redis + RQ**。
        * **理由是**：我們的架構中已經有了 Redis，RQ 是一個輕量級、基於 Redis 的任務佇列，非常易於整合。
        * **實作方式**：`ai-analysis-service` 提供一個觸發分析的 API，它會立即返回一個 `task_id`，然後將任務推入 RQ 佇列。前端可以透過另一個 API，使用 `task_id` 來輪詢任務狀態和結果。這完美地解決了長任務阻塞的問題，同時保持了架構的簡潔性。

---

## 5. 資料庫設計

#### 我們如何儲存與管理數據資產？

數據是我們平台的血液。我們沒有選擇單一的資料庫方案，而是採用了**混合持久化 (Polyglot Persistence)** 的策略，針對不同數據的特性選擇最適合的工具。

* **技術選型原因** (`03_system_design_document.md`)：
    * **PostgreSQL**：用於儲存使用者、學習歷程、分析結果等**結構化的關聯數據**。我們選擇它，是因為它的穩定性、事務一致性（ACID），以及強大的 JSONB 支援，讓我們可以在關聯模型中靈活地儲存半結構化數據。
    * **MongoDB**：用於儲存**題庫資料**。題目的結構多變，可能包含圖片、音檔，知識點標籤也不固定。MongoDB 的文檔模型提供了極大的靈活性，非常適合這種場景。
    * **Redis**：作為**快取層**和**任務佇列 Broker**。它被用來快取熱點數據（如用戶個人檔案）和管理 JWT Session，極大地提升了系統的回應速度。
    * **MinIO**：作為**物件儲存服務**，用來存放題目中的圖片、音檔等多媒體檔案。

* **資料庫設計邏輯** (`03_system_design_document.md` - ER 圖)：
    * 我們的核心是 `users`, `learning_sessions`, 和 `learning_records` 這三張表。
    * `users` 表定義了用戶的基本資訊和角色。
    * `learning_sessions` 記錄了一次完整的練習會話，包含了年級、科目等元數據。
    * `learning_records` 則詳細記錄了該次會話中每一道題的作答情況。
    * 特別值得一提的是，我們設計了 `weakness_analysis_history` 和 `learning_progress_snapshots` 這兩張表。它們不是簡單的流水記錄，而是經過 AI 分析和數據處理後的**結果沉澱**，這使得我們能夠快速地為家長和老師生成趨勢分析報告，而無需每次都從原始數據中進行大量計算。

* **實作遇到的困難與解決方案**：
    * **困難**：隨著學習記錄越來越多，如何保證弱點分析和趨勢報告的查詢效能？
    * **解決方案**：
        1.  **策略性索引**：我們不僅在 `user_id`、`session_id` 這種常用查詢欄位上建立了索引，還特別針對 `knowledge_points` 這種陣列欄位，使用了 PostgreSQL 的 **GIN 索引**，大幅提升了基於知識點的查詢速度。
        2.  **數據預處理**：如前所述，我們不會在前端請求時才即時計算所有分析數據。而是透過後端的非同步任務，定期將分析結果存入 `weakness_analysis_history` 和 `learning_progress_snapshots` 表中。這是一種典型的**以空間換時間**的策略，確保了前端報表頁面的秒級加載。
        3.  **讀寫分離（未來規劃）**：我們的架構設計也為未來的擴展預留了空間。當讀取壓力增大時，可以輕易地引入 PostgreSQL 的讀寫分離和從庫，來分散查詢負載。

---

**總結一下**，InULearning 專案是一個從真實痛點出發，以清晰目標為導向，並透過務實且先進的技術架構來實現的平台。我們在設計的每一個環節都深思熟慮，在快速迭代與系統穩健之間尋找最佳平衡。

我的分享到此結束，謝謝大家。現在開放提問。